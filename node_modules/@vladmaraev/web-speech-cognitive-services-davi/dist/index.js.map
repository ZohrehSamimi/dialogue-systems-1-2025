{"mappings":"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","sources":["src/index.ts","src/data/SpeechToText/createSpeechRecognitionPonyfill.ts","src/data/SpeechToText/cognitiveServiceEventResultToWebSpeechRecognitionResultList.ts","src/utils/arrayToMap.ts","src/data/SpeechSDK.ts","src/utils/createPromiseQueue.ts","src/data/patchOptions.ts","src/data/resolveFunctionOrReturnValue.ts","src/data/SpeechToText/SpeechGrammarList.ts","src/data/TextToSpeech/createSpeechSynthesisPonyfill.ts","src/data/TextToSpeech/SpeechSynthesisUtterance.ts","src/data/TextToSpeech/SpeechSynthesisVoice.ts","src/data/fetchAuthorizationToken.ts"],"sourcesContent":["import { createSpeechRecognitionPonyfill } from './data/SpeechToText/createSpeechRecognitionPonyfill';\nimport { SpeechSynthesis, createSpeechSynthesisPonyfill } from './data/TextToSpeech/createSpeechSynthesisPonyfill';\nimport fetchAuthorizationToken from './data/fetchAuthorizationToken';\nimport SpeechSynthesisUtterance from './data/TextToSpeech/SpeechSynthesisUtterance';\nimport SpeechGrammarList from './data/SpeechToText/SpeechGrammarList';\nimport type { PatchOptions } from './models/credentialTypes';\nimport type {\n  SpeechRecognitionProps,\n  SpeechSynthesisPonyfillType,\n  SpeechRecognitionPonyfillType\n} from './models/ponyfillTypes';\nimport type {\n  SpeechSynthesisEventProps,\n  SpeechRecognitionResultList,\n  SpeechRecognitionResultListItem\n} from './models/speechtypes';\n\nexport default function createSpeechServicesPonyfill(options: PatchOptions, recognitionData?: SpeechRecognitionProps) {\n  return {\n    ...createSpeechRecognitionPonyfill(options, recognitionData),\n    ...createSpeechSynthesisPonyfill(options)\n  };\n}\n\nexport {\n  createSpeechRecognitionPonyfill,\n  createSpeechSynthesisPonyfill,\n  fetchAuthorizationToken,\n  SpeechSynthesisUtterance,\n  SpeechSynthesis,\n  SpeechGrammarList\n};\n\nexport type {\n  PatchOptions,\n  SpeechSynthesisPonyfillType,\n  SpeechSynthesisEventProps,\n  SpeechRecognitionProps,\n  SpeechRecognitionPonyfillType,\n  SpeechRecognitionResultList,\n  SpeechRecognitionResultListItem\n};\n","/* eslint class-methods-use-this: \"off\" */\n/* eslint complexity: [\"error\", 70] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint no-empty-function: \"off\" */\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\n\nimport cognitiveServiceEventResultToWebSpeechRecognitionResultList from './cognitiveServiceEventResultToWebSpeechRecognitionResultList';\nimport createPromiseQueue from '../../utils/createPromiseQueue';\nimport patchOptions from '../patchOptions';\nimport SpeechGrammarList from './SpeechGrammarList';\nimport * as SDK from 'microsoft-cognitiveservices-speech-sdk';\nimport type {\n  SpeechRecognitionResultListItem,\n  SpeechRecognitionResultList,\n  SpeechRecognitionResultParsed\n} from '../../models/speechtypes';\nimport type { SpeechRecognitionProps } from '../../models/ponyfillTypes';\nimport type { PatchOptions } from '../../models/credentialTypes';\nimport { DynamicGrammarBuilder } from 'microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarBuilder';\n\ninterface AudioConfigImpl extends SDK.AudioConfig {\n  attach: Function;\n  detach: Function;\n  events: any;\n}\n\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\n// const { AudioConfig, OutputFormat, ResultReason, SpeechConfig, SpeechRecognizer } = SDK;\n\nfunction serializeRecognitionResult({\n  duration,\n  errorDetails,\n  json,\n  offset,\n  properties,\n  reason,\n  resultId,\n  text\n}): SpeechRecognitionResultParsed {\n  return {\n    duration,\n    errorDetails,\n    json: JSON.parse(json),\n    offset,\n    properties,\n    reason,\n    resultId,\n    text\n  };\n}\n\nfunction averageAmplitude(arrayBuffer: ArrayBuffer) {\n  const array = new Int16Array(arrayBuffer);\n\n  return array.reduce((averageAmplitude, amplitude) => averageAmplitude + Math.abs(amplitude), 0) / array.length;\n}\n\nfunction cognitiveServicesAsyncToPromise(fn: Function): any {\n  return (...args) => new Promise((resolve, reject) => fn(...args, resolve, reject));\n}\n\nfunction prepareAudioConfig(audioConfig: AudioConfigImpl) {\n  const originalAttach = audioConfig.attach;\n  const boundOriginalAttach = audioConfig.attach.bind(audioConfig);\n  let firstChunk = false;\n  let muted = false;\n\n  // We modify \"attach\" function and detect when audible chunk is read.\n  // We will only modify \"attach\" function once.\n  audioConfig.attach = async () => {\n    const reader = await boundOriginalAttach();\n\n    return {\n      ...reader,\n      read: async () => {\n        const chunk = await reader.read();\n\n        // The magic number 150 is measured by:\n        // 1. Set microphone volume to 0\n        // 2. Observe the amplitude (100-110) for the first few chunks\n        //    (There is a short static caught when turning on the microphone)\n        // 3. Set the number a bit higher than the observation\n\n        if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\n          audioConfig.events.onEvent({ name: 'FirstAudibleChunk' });\n          firstChunk = true;\n        }\n\n        if (muted) {\n          return { buffer: new ArrayBuffer(0), isEnd: true, timeReceived: Date.now() };\n        }\n\n        return chunk;\n      }\n    };\n  };\n\n  return {\n    audioConfig,\n    pause: () => {\n      muted = true;\n    },\n    unprepare: () => {\n      audioConfig.attach = originalAttach;\n    }\n  };\n}\n\nclass SpeechRecognition {\n  audioConfig: SDK.AudioConfig | null = null;\n  speechConfig: SDK.SpeechConfig | null = null;\n  recognizer: SDK.SpeechRecognizer | null = null;\n\n  enableTelemetry = true;\n  looseEvents = false;\n  referenceGrammars: any;\n  textNormalization: string = 'display';\n\n  started = false;\n\n  private _autoStart = false;\n  private _passive = false;\n  private _wakeWords: Array<string>;\n  private _continuous = false;\n  private _interimResults = true;\n  private _lang: string;\n  private _grammars: SpeechGrammarList = new SpeechGrammarList();\n  private _maxAlternatives = 1;\n  private _debug = false;\n\n  constructor(options: PatchOptions, data?: SpeechRecognitionProps) {\n    this._autoStart = !!data?.autoStart;\n    this._passive = !!data?.passive;\n    this._wakeWords = data?.wakeWords || [];\n    this._continuous = !!data?.continuous;\n    this._interimResults = !(data?.interimResults === false);\n    this._lang = data?.lang\n      ? data.lang\n      : typeof window !== 'undefined'\n      ? window.document.documentElement.getAttribute('lang') || window.navigator.language\n      : 'en-US';\n    data?.grammarsList && (this._grammars.phrases = data.grammarsList);\n    this._debug = !!data?.debug || false;\n\n    const {\n      audioConfig = null,\n      // We set telemetry to true to honor the default telemetry settings of Speech SDK\n      // https://github.com/Microsoft/cognitive-services-speech-sdk-js#data--telemetry\n      enableTelemetry = true,\n      fetchCredentials,\n      looseEvents,\n      referenceGrammars,\n      speechRecognitionEndpointId,\n      textNormalization = 'display'\n    } = patchOptions(options);\n\n    this.enableTelemetry = enableTelemetry;\n    this.looseEvents = !!looseEvents;\n    this.referenceGrammars = referenceGrammars;\n    this.textNormalization = textNormalization;\n\n    if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\n      console.warn(\n        'web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.'\n      );\n    } else {\n      try {\n        this.audioConfig = audioConfig || SDK.AudioConfig.fromDefaultMicrophoneInput();\n\n        this.initRecognizer(fetchCredentials, speechRecognitionEndpointId, data?.timerBeforeSpeechEnd);\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n  }\n\n  get passive() {\n    return this._passive;\n  }\n\n  set passive(value) {\n    this._passive = value;\n  }\n\n  get wakeWords() {\n    return this._wakeWords;\n  }\n\n  set wakeWords(value) {\n    this._wakeWords = value;\n  }\n\n  get continuous() {\n    return this._continuous;\n  }\n\n  set continuous(value) {\n    this._continuous = value;\n  }\n\n  get grammars() {\n    return this._grammars;\n  }\n\n  set grammars(value) {\n    if (value instanceof SpeechGrammarList) {\n      this._grammars = value;\n    } else {\n      throw new Error(`The provided value is not of type 'SpeechGrammarList'`);\n    }\n  }\n\n  get interimResults() {\n    return this._interimResults;\n  }\n\n  set interimResults(value) {\n    this._interimResults = value;\n  }\n\n  get maxAlternatives() {\n    return this._maxAlternatives;\n  }\n\n  set maxAlternatives(value) {\n    this._maxAlternatives = value;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  set lang(value) {\n    this._lang = value;\n  }\n\n  onstart = (): void => {};\n  onend = (): void => {};\n\n  onpassivestart = (): void => {};\n  onpassiveend = (): void => {};\n\n  onaudiostart = (): void => {};\n  onaudioend = (): void => {};\n\n  onsoundstart = (): void => {};\n  onsoundend = (): void => {};\n\n  onspeechstart = (): void => {};\n  onspeechend = (): void => {};\n\n  onerror = (value: any): void => {\n    console.log('Error : ', value);\n  };\n  onabort = (): void => {\n    this._debug && console.log('Recognition aborted');\n  };\n\n  onresult = (value: SpeechRecognitionResultList): void => {\n    this._debug && console.log('Result : ', value);\n  };\n\n  onpassiveresult = (value: Array<SpeechRecognitionResultListItem> | SpeechRecognitionResultList): void => {\n    this._debug && console.log('Passive Result : ', value);\n  };\n\n  onwakeup = (): void => {\n    this._debug && console.log('Wake up !');\n  };\n\n  start = (): void => {\n    this._startOnce().catch(err => {\n      new Error(`error : ${err.message}\\ncallstack : ${err.stack}`);\n    });\n  };\n\n  abort: Function | undefined = undefined;\n  stop: Function | undefined = undefined;\n\n  /**\n   * Retrieval of credentials, initialization of speechConfig and start recognizing\n   * @param fetchCredentials Function\n   * @param speechRecognitionEndpointId string | undefined\n   */\n  initRecognizer = async (\n    fetchCredentials: Function,\n    speechRecognitionEndpointId?: string,\n    timerBeforeSpeechEnd?: number\n  ): Promise<void> => {\n    const {\n      authorizationToken,\n      region = 'westus',\n      speechRecognitionHostname,\n      subscriptionKey\n    } = await fetchCredentials();\n\n    if (speechRecognitionHostname) {\n      if (authorizationToken) {\n        this.speechConfig = SDK.SpeechConfig.fromHost(new URL(`wss://${speechRecognitionHostname}`));\n        this.speechConfig.authorizationToken = authorizationToken;\n      } else {\n        this.speechConfig = SDK.SpeechConfig.fromHost(new URL(`wss://${speechRecognitionHostname}`), subscriptionKey);\n      }\n    } else if (region && (authorizationToken || subscriptionKey)) {\n      this.speechConfig = authorizationToken\n        ? SDK.SpeechConfig.fromAuthorizationToken(authorizationToken, region)\n        : subscriptionKey\n        ? SDK.SpeechConfig.fromSubscription(subscriptionKey, region)\n        : null;\n    }\n\n    if (this.speechConfig) {\n      if (speechRecognitionEndpointId && this.speechConfig) {\n        this.speechConfig.endpointId = speechRecognitionEndpointId;\n      }\n\n      this.speechConfig.outputFormat = SDK.OutputFormat.Detailed;\n      this.speechConfig.speechRecognitionLanguage = this._lang || 'en-US';\n      timerBeforeSpeechEnd &&\n        this.speechConfig.setProperty(\n          SDK.PropertyId[SDK.PropertyId.Speech_SegmentationSilenceTimeoutMs],\n          `${timerBeforeSpeechEnd}`\n        );\n\n      this._autoStart && this.start();\n    }\n  };\n\n  /**\n   * Create a new Synthesizer from audioConfig / speechConfig / lang\n   * @param lang string\n   */\n  createRecognizer = async (): Promise<void> => {\n    if (this.audioConfig && this.speechConfig) {\n      this.speechConfig.speechRecognitionLanguage = this._lang;\n      this.recognizer = new SDK.SpeechRecognizer(this.speechConfig, this.audioConfig);\n\n      // Add grammars\n      const { dynamicGrammar } = this.recognizer.internalData as any;\n      this.referenceGrammars &&\n        this.referenceGrammars.length &&\n        (dynamicGrammar as DynamicGrammarBuilder).addReferenceGrammar(this.referenceGrammars);\n\n      // Add phrases\n      const { phrases } = this._grammars;\n      if (phrases && phrases.length) {\n        const phraseList = SDK.PhraseListGrammar.fromRecognizer(this.recognizer);\n        phrases.forEach(phrase => {\n          phraseList.addPhrase(phrase);\n        });\n      }\n    } else {\n      this.recognizer = null;\n    }\n  };\n\n  /**\n   * Stop current recognizer, change language and start a new recognition\n   * @param lang string\n   */\n  changeLanguage = async (lang?: string): Promise<void> => {\n    if (this.recognizer && this.audioConfig && this.speechConfig && lang && lang !== this._lang) {\n      // Stop current recognition and start a new one\n      await cognitiveServicesAsyncToPromise(this.recognizer.stopContinuousRecognitionAsync.bind(this.recognizer))();\n      this._lang = lang;\n      this._continuous && this.start();\n    } else {\n      this.recognizer = null;\n    }\n  };\n\n  /**\n   * In continuous mode, toggle from passive to active mode by stopping current recognition and starting a new one to prevent\n   * receiving results from a current passive speech recognition.\n   * If you don't care about having existing results in active recognition, just set recognition's 'passive' variable to 'false' instead\n   * of using this method.\n   */\n  toggleContinuousPassiveToActive = async (): Promise<void> => {\n    if (this._continuous && this.recognizer && this.audioConfig && this.speechConfig) {\n      // Stop current recognition and start a new one\n      if (this.started) {\n        await cognitiveServicesAsyncToPromise(this.recognizer.stopContinuousRecognitionAsync.bind(this.recognizer))();\n      }\n      this._continuous = false;\n      this._passive = false;\n      this.start();\n    }\n  };\n\n  /**\n   * In continuous mode, toggle from passive to active mode by stopping current recognition and starting a new one to prevent\n   * receiving results from a current passive speech recognition.\n   * If you don't care about having existing results in active recognition, just set recognition's 'passive' variable to 'false' instead\n   * of using this method.\n   */\n  toggleContinuousActiveToPassive = async (): Promise<void> => {\n    if (!this._continuous && this.recognizer && this.audioConfig && this.speechConfig) {\n      // Stop current recognition and start a new one\n      if (this.started) {\n        await cognitiveServicesAsyncToPromise(this.recognizer.stopContinuousRecognitionAsync.bind(this.recognizer))();\n      }\n\n      this._continuous = true;\n      this._passive = true;\n      this.start();\n    }\n  };\n\n  processSendEvent = (type: string, data?: any): void => {\n    this._debug && console.log('Speech Recognizer Event : type = ', type, '\\n, data = ', data);\n    switch (type) {\n      case 'start': {\n        if (this._passive) {\n          this.onpassivestart && this.onpassivestart();\n        } else {\n          this.onstart && this.onstart();\n        }\n        this.started = true;\n        break;\n      }\n      case 'end':\n        if (this._passive) {\n          this.onpassiveend && this.onpassiveend();\n        } else {\n          this.onend && this.onend();\n        }\n        this.started = false;\n        break;\n      case 'audiostart':\n        this.onaudiostart && this.onaudiostart();\n        break;\n      case 'audioend':\n        this.onaudioend && this.onaudioend();\n        break;\n      case 'soundstart':\n        this.onsoundstart && this.onsoundstart();\n        break;\n      case 'soundend':\n        this.onsoundend && this.onsoundend();\n        break;\n      case 'speechstart':\n        this.onspeechstart && this.onspeechstart();\n        break;\n      case 'speechend':\n        this.onspeechend && this.onspeechend();\n        break;\n      case 'error':\n        this.onerror && this.onerror(data);\n        this.started = false;\n        break;\n      case 'abort':\n        this.onabort && this.onabort();\n        this.started = false;\n        break;\n      case 'result':\n        this.onresult && this.onresult(data.results);\n        break;\n      case 'passiveresult':\n        this.onpassiveresult && this.onpassiveresult(data.results);\n        break;\n      case 'wakeup':\n        this.onwakeup && this.onwakeup();\n        break;\n    }\n  };\n\n  async _startOnce(): Promise<void> {\n    if (this.audioConfig && !this.started) {\n      const { pause, unprepare } = prepareAudioConfig(this.audioConfig as AudioConfigImpl);\n\n      const queue = createPromiseQueue();\n      let soundStarted = false;\n      let speechStarted = false;\n      let stopping = '';\n\n      const { detach: detachAudioConfigEvent } = (this.audioConfig as AudioConfigImpl).events.attach(event => {\n        const { name } = event;\n\n        if (name === 'AudioSourceReadyEvent') {\n          queue.push({ audioSourceReady: {} });\n        } else if (name === 'AudioSourceOffEvent') {\n          queue.push({ audioSourceOff: {} });\n        } else if (name === 'FirstAudibleChunk') {\n          queue.push({ firstAudibleChunk: {} });\n        }\n      });\n\n      await this.createRecognizer();\n\n      if (this.recognizer) {\n        try {\n          this.recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }) => {\n            queue.push({\n              canceled: {\n                errorDetails,\n                offset,\n                reason,\n                sessionId\n              }\n            });\n          };\n\n          this.recognizer.recognized = (_, { offset, result, sessionId }) => {\n            queue.push({\n              recognized: {\n                offset,\n                result: serializeRecognitionResult(result),\n                sessionId\n              }\n            });\n          };\n\n          this.recognizer.recognizing = (_, { offset, result, sessionId }) => {\n            queue.push({\n              recognizing: {\n                offset,\n                result: serializeRecognitionResult(result),\n                sessionId\n              }\n            });\n          };\n\n          this.recognizer.sessionStarted = (_, { sessionId }) => {\n            queue.push({ sessionStarted: { sessionId } });\n          };\n\n          this.recognizer.sessionStopped = (_, { sessionId }) => {\n            // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n            queue.push({ sessionStopped: { sessionId } });\n          };\n\n          this.recognizer.speechStartDetected = (_, { offset, sessionId }) => {\n            queue.push({ speechStartDetected: { offset, sessionId } });\n          };\n\n          this.recognizer.speechEndDetected = (_, { sessionId }) => {\n            // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n            // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\n            queue.push({ speechEndDetected: { sessionId } });\n          };\n\n          await cognitiveServicesAsyncToPromise(\n            this.recognizer.startContinuousRecognitionAsync.bind(this.recognizer)\n          )();\n\n          this.abort = () => queue.push({ abort: {} });\n          this.stop = () => queue.push({ stop: {} });\n\n          let audioStarted = false;\n          let finalEvent: {\n            type: string;\n            data?: string | { results: Array<SpeechRecognitionResultListItem> | SpeechRecognitionResultList };\n          } | null = null;\n          let finalizedResults: SpeechRecognitionResultList = [];\n          finalizedResults.isFinal = false;\n\n          for (let loop = 0; !stopping || audioStarted; loop++) {\n            const event = await queue.shift();\n            const {\n              abort,\n              audioSourceOff,\n              audioSourceReady,\n              canceled,\n              firstAudibleChunk,\n              recognized,\n              recognizing,\n              stop\n            } = event;\n\n            const errorMessage = canceled && canceled.errorDetails;\n\n            if (/Permission\\sdenied/u.test(errorMessage || '')) {\n              // If microphone is not allowed, we should not emit \"start\" event.\n              finalEvent = {\n                data: 'not-allowed',\n                type: 'error'\n              };\n\n              break;\n            }\n\n            if (!loop) {\n              this.processSendEvent('start');\n            }\n\n            if (errorMessage) {\n              if (/1006/u.test(errorMessage)) {\n                if (!audioStarted) {\n                  this.processSendEvent('audiostart');\n                  this.processSendEvent('audioend');\n                }\n\n                finalEvent = {\n                  data: 'network',\n                  type: 'error'\n                };\n              } else {\n                finalEvent = {\n                  data: 'unknown',\n                  type: 'error'\n                };\n              }\n\n              break;\n            } else if (abort || stop) {\n              if (abort) {\n                finalEvent = {\n                  type: 'abort'\n                };\n\n                // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\n                stopping = 'abort';\n              } else {\n                // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\n                pause();\n                stopping = 'stop';\n              }\n\n              // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\n              // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\n              if (abort && this.recognizer.stopContinuousRecognitionAsync) {\n                await cognitiveServicesAsyncToPromise(\n                  this.recognizer.stopContinuousRecognitionAsync.bind(this.recognizer)\n                )();\n              }\n            } else if (audioSourceReady) {\n              this.processSendEvent('audiostart');\n              audioStarted = true;\n            } else if (firstAudibleChunk) {\n              this.processSendEvent('soundstart');\n              soundStarted = true;\n            } else if (audioSourceOff) {\n              // Looks like we don't need this line and all the tests are still working.\n              // Guessing probably stopping is already truthy.\n              // stopping = true;\n\n              speechStarted && this.processSendEvent('speechend');\n              soundStarted && this.processSendEvent('soundend');\n              audioStarted && this.processSendEvent('audioend');\n\n              audioStarted = soundStarted = speechStarted = false;\n\n              break;\n            } else if (stopping !== 'abort') {\n              if (recognized && recognized.result && recognized.result.reason === SDK.ResultReason.NoMatch) {\n                finalEvent = {\n                  data: 'no-speech',\n                  type: 'error'\n                };\n              } else if (recognized || recognizing) {\n                if (!audioStarted) {\n                  // Unconfirmed prevention of quirks\n                  this.processSendEvent('audiostart');\n                  audioStarted = true;\n                }\n\n                if (!soundStarted) {\n                  this.processSendEvent('soundstart');\n                  soundStarted = true;\n                }\n\n                if (!speechStarted) {\n                  this.processSendEvent('speechstart');\n                  speechStarted = true;\n                }\n\n                if (recognized) {\n                  const result = cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognized.result, {\n                    maxAlternatives: this.maxAlternatives,\n                    textNormalization: this.textNormalization\n                  });\n\n                  const recognizable = !!result[0].transcript;\n\n                  if (recognizable) {\n                    finalizedResults = [...finalizedResults, ...result];\n                    finalizedResults.isFinal = result.isFinal;\n\n                    if (this._interimResults) {\n                      this.processSendEvent('result', {\n                        results: finalizedResults\n                      });\n\n                      this._passive &&\n                        this.processSendEvent('passiveresult', {\n                          results: result\n                        });\n                    }\n                  }\n\n                  // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\n                  if (this._continuous && recognizable) {\n                    finalEvent = null;\n                  } else {\n                    this._interimResults &&\n                      (finalEvent = {\n                        data: {\n                          results: finalizedResults\n                        },\n                        type: 'result'\n                      });\n                  }\n\n                  if (!this._continuous && this.recognizer.stopContinuousRecognitionAsync) {\n                    await cognitiveServicesAsyncToPromise(\n                      this.recognizer.stopContinuousRecognitionAsync.bind(this.recognizer)\n                    )();\n                  }\n\n                  // If event order can be loosened, we can send the recognized event as soon as we receive it.\n                  // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\n                  if (this.looseEvents && finalEvent && recognizable) {\n                    this.processSendEvent(finalEvent.type, finalEvent.data);\n                    finalEvent = null;\n                  }\n                } else if (recognizing) {\n                  const result = cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognizing.result, {\n                    maxAlternatives: this.maxAlternatives,\n                    textNormalization: this.textNormalization\n                  });\n\n                  if (this._passive && this._wakeWords && this._wakeWords.length > 0) {\n                    // Test wake words if some are present\n                    if (result && Array.isArray(result) && result.length > 0 && result[0].transcript) {\n                      const { transcript } = { ...result[0] };\n                      this._wakeWords.forEach(wakeWord => {\n                        if (transcript.toLowerCase().includes(wakeWord.toLowerCase())) {\n                          this.processSendEvent('wakeup');\n                        }\n                      });\n                    }\n\n                    this._interimResults &&\n                      this.processSendEvent('passiveresult', {\n                        results: result\n                      });\n                  }\n\n                  this._interimResults &&\n                    this.processSendEvent('result', {\n                      results: [...finalizedResults, ...result]\n                    });\n                }\n              }\n            }\n          }\n\n          speechStarted && this.processSendEvent('speechend');\n          soundStarted && this.processSendEvent('soundend');\n          audioStarted && this.processSendEvent('audioend');\n\n          if (finalEvent) {\n            if (\n              finalEvent.type === 'result' &&\n              (typeof finalEvent.data === 'string' || !finalEvent.data?.results || !finalEvent.data.results.length)\n            ) {\n              finalEvent = {\n                data: 'no-speech',\n                type: 'error'\n              };\n            }\n\n            this.processSendEvent(finalEvent.type, finalEvent.data);\n          }\n\n          // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n          // This is mainly for \"microphone blocked\" story.\n          this.processSendEvent('end');\n          detachAudioConfigEvent && detachAudioConfigEvent();\n        } catch (err) {\n          // Logging out the erorr because Speech SDK would fail silently.\n          console.error(err);\n\n          throw err;\n        } finally {\n          unprepare();\n          this.recognizer.close();\n        }\n      }\n    }\n  }\n}\n\nconst createSpeechRecognitionPonyfill = (options: PatchOptions, data?: SpeechRecognitionProps) => {\n  return {\n    speechRecognition: new SpeechRecognition(options, data),\n    SpeechGrammarList\n  };\n};\n\nexport default createSpeechRecognitionPonyfill;\nexport { createSpeechRecognitionPonyfill, SpeechRecognition };\n","import arrayToMap from '../../utils/arrayToMap';\nimport SpeechSDK from '../SpeechSDK';\nimport type {\n  SpeechRecognitionResultListItem,\n  SpeechRecognitionResultList,\n  SpeechRecognitionResultParsed\n} from '../../models/speechtypes';\n\nconst {\n  ResultReason: { RecognizingSpeech, RecognizedSpeech }\n} = SpeechSDK;\n\nexport default function (\n  result: SpeechRecognitionResultParsed,\n  { maxAlternatives = Infinity, textNormalization = 'display' } = {}\n): SpeechRecognitionResultList {\n  if (result.reason === RecognizingSpeech || (result.reason === RecognizedSpeech && !result.json.NBest)) {\n    const resultList: SpeechRecognitionResultList = [\n      {\n        confidence: 0.5,\n        transcript: result.text\n      }\n    ];\n    if (result.reason === RecognizedSpeech) {\n      resultList.isFinal = true;\n    }\n\n    return resultList;\n  } else if (result.reason === RecognizedSpeech) {\n    const resultList: SpeechRecognitionResultList = arrayToMap(\n      (result.json.NBest || []).slice(0, maxAlternatives).map(\n        ({\n          Confidence: confidence,\n          Display: display,\n          ITN: itn,\n          Lexical: lexical,\n          MaskedITN: maskedITN\n        }): SpeechRecognitionResultListItem => ({\n          confidence,\n          transcript:\n            textNormalization === 'itn'\n              ? itn\n              : textNormalization === 'lexical'\n              ? lexical\n              : textNormalization === 'maskeditn'\n              ? maskedITN\n              : display\n        })\n      ),\n      { isFinal: true }\n    );\n\n    return resultList;\n  }\n\n  return [];\n}\n","export default function (array, extras) {\n  const map = {\n    // @ts-ignore\n    ...[].reduce.call(\n      array,\n      (map, value, index) => {\n        // @ts-ignore\n        map[index] = value;\n\n        return map;\n      },\n      {}\n    ),\n    ...extras,\n    length: array.length,\n    [Symbol.iterator]: () => [].slice.call(map)[Symbol.iterator]()\n  };\n\n  return map;\n}\n","import {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer,\n  SpeechSynthesizer\n} from 'microsoft-cognitiveservices-speech-sdk';\n\nimport type { SpeechRecognitionResult, SpeechRecognizer as SpeechRecognizerType, SpeechConfig as SpeechConfigType } from 'microsoft-cognitiveservices-speech-sdk'\n\nexport default {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer,\n  SpeechSynthesizer\n};\n\nexport {\n  AudioConfig,\n  OutputFormat,\n  ResultReason,\n  SpeechConfig,\n  SpeechRecognizer,\n  SpeechSynthesizer\n};\n\nexport type { SpeechRecognitionResult, SpeechRecognizerType, SpeechConfigType }\n","import createDeferred from 'p-defer-es5';\n\nexport default function() {\n  let shiftDeferred;\n  const queue: Array<any> = [];\n\n  const push = value => {\n    if (shiftDeferred) {\n      const { resolve } = shiftDeferred;\n\n      shiftDeferred = null;\n      resolve(value);\n    } else {\n      queue.push(value);\n    }\n  };\n\n  const shift = () => {\n    if (queue.length) {\n      return Promise.resolve(queue.shift());\n    }\n\n    return (shiftDeferred || (shiftDeferred = createDeferred())).promise;\n  };\n\n  return {\n    push,\n    shift\n  };\n}\n","import { Credentials, PatchOptions } from '../models/credentialTypes';\nimport resolveFunctionOrReturnValue from './resolveFunctionOrReturnValue';\n\nlet shouldWarnOnSubscriptionKey = true;\n\nexport default function patchOptions({\n  credentials,\n  looseEvents,\n  ...otherOptions\n}: PatchOptions ) {\n  if (!credentials) {\n    throw new Error('web-speech-cognitive-services: Credentials must be specified.');\n  }\n\n  return {\n    ...otherOptions,\n    fetchCredentials: async () => {\n      const {\n        authorizationToken,\n        customVoiceHostname,\n        region,\n        speechRecognitionHostname,\n        speechSynthesisHostname,\n        subscriptionKey\n      } = await resolveFunctionOrReturnValue(credentials);\n\n      if ((!authorizationToken && !subscriptionKey) || (authorizationToken && subscriptionKey)) {\n        throw new Error(\n          'web-speech-cognitive-services: Either \"authorizationToken\" or \"subscriptionKey\" must be provided.'\n        );\n      } else if (!region && !(speechRecognitionHostname && speechSynthesisHostname)) {\n        throw new Error(\n          'web-speech-cognitive-services: Either \"region\" or \"speechRecognitionHostname\" and \"speechSynthesisHostname\" must be set.'\n        );\n      } else if (region && (customVoiceHostname || speechRecognitionHostname || speechSynthesisHostname)) {\n        throw new Error(\n          'web-speech-cognitive-services: Only either \"region\" or \"customVoiceHostname\", \"speechRecognitionHostname\" and \"speechSynthesisHostname\" can be set.'\n        );\n      } else if (authorizationToken) {\n        if (typeof authorizationToken !== 'string') {\n          throw new Error('web-speech-cognitive-services: \"authorizationToken\" must be a string.');\n        }\n      } else if (typeof subscriptionKey !== 'string') {\n        throw new Error('web-speech-cognitive-services: \"subscriptionKey\" must be a string.');\n      }\n\n      if (shouldWarnOnSubscriptionKey && subscriptionKey) {\n        console.warn(\n          'web-speech-cognitive-services: In production environment, subscription key should not be used, authorization token should be used instead.'\n        );\n\n        shouldWarnOnSubscriptionKey = false;\n      }\n\n      const resolvedCredentials: Credentials = {\n        region,\n        authorizationToken,\n        subscriptionKey,\n        customVoiceHostname,\n        speechRecognitionHostname,\n        speechSynthesisHostname\n      };\n\n      return resolvedCredentials;\n    },\n    looseEvents\n  };\n}\n","export default function resolveFunctionOrReturnValue(fnOrValue: any): any {\n  return typeof fnOrValue === 'function' ? fnOrValue() : fnOrValue;\n}\n","/* eslint class-methods-use-this: \"off\" */\n\nexport default class {\n  _phrases: Array<string> = [];\n\n  addFromString(): void {\n    throw new Error('JSGF is not supported');\n  }\n\n  get phrases(): Array<string> {\n    return this._phrases;\n  }\n\n  set phrases(value: Array<string> | string) {\n    if (Array.isArray(value)) {\n      this._phrases = value;\n    } else if (typeof value === 'string') {\n      this._phrases = [value];\n    } else {\n      throw new Error(`The provided value is not an array or of type 'string'`);\n    }\n  }\n}\n","import * as SDK from 'microsoft-cognitiveservices-speech-sdk';\nimport patchOptions from '../patchOptions';\nimport SpeechSynthesisUtterance from './SpeechSynthesisUtterance';\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\nimport type { SpeechSynthesisPonyfillType } from '../../models/ponyfillTypes';\nimport type { PatchOptions } from '../../models/credentialTypes';\n\nclass SpeechSynthesis {\n  speaking = false;\n  speakerAudioDestination: SDK.SpeakerAudioDestination = new SDK.SpeakerAudioDestination();\n  audioConfig: SDK.AudioConfig | undefined = undefined;\n  speechConfig: SDK.SpeechConfig | null = null;\n  queue: Array<SpeechSynthesisUtterance> = [];\n  canceled = false;\n  synth: SDK.SpeechSynthesizer | null = null;\n  synthesizing: boolean = false;\n\n  constructor(options: PatchOptions) {\n    // Extract parameters from options using the patchOptions function\n    const {\n      audioContext,\n      fetchCredentials,\n      ponyfill = {\n        // @ts-ignore\n        AudioContext: window.AudioContext || window.webkitAudioContext\n      },\n      speechSynthesisDeploymentId\n    } = patchOptions(options);\n\n    // Check if the browser supports the Web Audio API, if not, return an empty object\n    if (!audioContext && !ponyfill.AudioContext) {\n      console.warn(\n        'web-speech-cognitive-services: This browser does not support Web Audio and it will not work with Cognitive Services Speech Services.'\n      );\n    } else {\n      this.audioConfig = SDK.AudioConfig.fromSpeakerOutput(this.speakerAudioDestination);\n      // Init synthesizer\n      this.initSpeechSynthesizer(fetchCredentials, speechSynthesisDeploymentId);\n    }\n  }\n\n  mute(): void {\n    this.speakerAudioDestination && this.speakerAudioDestination.mute();\n  }\n\n  unmute(): void {\n    this.speakerAudioDestination && this.speakerAudioDestination.unmute();\n  }\n\n  getVolume(): number {\n    // eslint-disable-next-line no-magic-numbers\n    return this.speakerAudioDestination ? this.speakerAudioDestination.volume : -1;\n  }\n\n  setVolume(value: number): void {\n    this.speakerAudioDestination && (this.speakerAudioDestination.volume = value);\n  }\n\n  // Asynchronous function that initializes the speech synthesizer class\n  async initSpeechSynthesizer(fetchCredentials: Function, speechSynthesisDeploymentId?: string): Promise<void> {\n    const { speechSynthesisHostname, subscriptionKey, authorizationToken, region } = await fetchCredentials();\n\n    if (!authorizationToken && !subscriptionKey) {\n      throw new Error('no subscription data : authorizationToken or subscriptionKey needed');\n    }\n\n    // Configure the synthesizer and audio\n    if (speechSynthesisDeploymentId) {\n      const hostname = speechSynthesisHostname || `${region}.customvoice.api.speech.microsoft.com`;\n      const url = `https://${encodeURI(hostname)}/api/texttospeech/v2.0/endpoints/${encodeURIComponent(\n        speechSynthesisDeploymentId\n      )}`;\n\n      this.speechConfig = SDK.SpeechConfig.fromEndpoint(new URL(url), subscriptionKey);\n    } else {\n      if (speechSynthesisHostname) {\n        this.speechConfig = SDK.SpeechConfig.fromHost(speechSynthesisHostname, subscriptionKey);\n      } else {\n        this.speechConfig = authorizationToken\n          ? SDK.SpeechConfig.fromAuthorizationToken(authorizationToken, region)\n          : SDK.SpeechConfig.fromSubscription(subscriptionKey, region);\n      }\n    }\n    this.synth = new SDK.SpeechSynthesizer(this.speechConfig, this.audioConfig);\n\n    // Update available voices\n    this.updateVoices();\n  }\n\n  // Function to recreate the synthesizer\n  createSynthesizer(voice: string | undefined, stream: SDK.AudioOutputStream | undefined | null): void {\n    if (stream) {\n      this.audioConfig = SDK.AudioConfig.fromStreamOutput(stream);\n    } else {\n      this.speakerAudioDestination = new SDK.SpeakerAudioDestination();\n      this.audioConfig = SDK.AudioConfig.fromSpeakerOutput(this.speakerAudioDestination);\n    }\n\n    if (this.speechConfig) {\n      if (voice) {\n        const tempSpeechConfig = this.speechConfig;\n        tempSpeechConfig.speechSynthesisVoiceName = voice;\n        this.synth = new SDK.SpeechSynthesizer(tempSpeechConfig, this.audioConfig);\n      } else {\n        this.synth = new SDK.SpeechSynthesizer(this.speechConfig, this.audioConfig);\n      }\n    }\n  }\n\n  // Cancel current synthesis\n  cancel(): void {\n    if (this.synthesizing) {\n      try {\n        // @ts-ignore\n        this.synth && !this.synth.privDisposed && this.synth.close();\n        this.queue = [];\n      } catch (e) {\n        console.warn(e);\n      }\n    } else if (this.speaking) {\n      try {\n        this.speakerAudioDestination.pause();\n        this.speakerAudioDestination.onAudioEnd(this.speakerAudioDestination);\n        this.speakerAudioDestination.close();\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n    this.queue = [];\n    this.canceled = true;\n  }\n\n  // Pause current synthesis\n  pause(): void {\n    if (this.speakerAudioDestination) {\n      this.speakerAudioDestination.pause();\n    }\n  }\n\n  // Resume current synthesis\n  resume(): void {\n    if (this.speakerAudioDestination && !this.canceled) {\n      this.speakerAudioDestination.resume();\n    }\n  }\n\n  // Function that returns an empty array of available voices\n  getVoices = (): Array<SpeechSynthesisVoice> => {\n    return [];\n  };\n\n  onvoiceschanged = (): void => {};\n\n  /**\n   * Add events listeners to the events received by the synthesizer if callbakcs are given in the utterance\n   * @param {SpeechSynthesisUtterance} utterance\n   */\n  linkEventsCallbacks(utterance) {\n    if (this.synth) {\n      // Events callbacks\n      this.synth.synthesisStarted = () => {\n        utterance.onsynthesisstart && utterance.onsynthesisstart();\n        this.synthesizing = true;\n      };\n\n      this.synth.synthesisCompleted = () => {\n        utterance.onsynthesiscompleted && utterance.onsynthesiscompleted();\n        this.synthesizing = false;\n      };\n\n      this.synth.wordBoundary = (synth, e) => {\n        !synth && console.warn('No synthesizer');\n        const data = {\n          boundaryType: e.boundaryType,\n          name: e.text,\n          elapsedTime: e.audioOffset,\n          duration: e.duration\n        };\n\n        utterance.onboundary && utterance.onboundary(data);\n      };\n\n      this.synth.visemeReceived = (synth, e) => {\n        !synth && console.warn('No synthesizer');\n        const data = {\n          boundaryType: 'Viseme',\n          name: `${e.visemeId}`,\n          animation: e.animation,\n          elapsedTime: e.audioOffset,\n          duration: 0\n        };\n\n        utterance.onboundary && utterance.onboundary(data);\n        utterance.onviseme && utterance.onviseme(data);\n      };\n\n      this.synth.bookmarkReached = (synth, e) => {\n        !synth && console.warn('No synthesizer');\n        const data = {\n          boundaryType: 'Mark',\n          name: e.text,\n          elapsedTime: e.audioOffset,\n          duration: 0\n        };\n\n        utterance.onmark && utterance.onmark(data);\n      };\n    }\n  }\n\n  /**\n   * Launch synthesis and play sound with the speech synthesizer\n   * @param {SpeechSynthesisUtterance} utterance\n   */\n  speak(utterance: SpeechSynthesisUtterance, stream: SDK.AudioOutputStream | undefined | null) {\n    // Test utterance\n    if (!(utterance instanceof SpeechSynthesisUtterance)) {\n      throw new Error('invalid utterance');\n    }\n\n    // Add the utterance to the queue\n    this.queue.push(utterance);\n\n    // Function to process the queued utterances\n    const processQueue = (): any => {\n      if (this.queue.length && !this.speaking) {\n        const currentUtterance = this.queue.shift(); // Get the next utterance from the queue\n        if (currentUtterance) {\n          const isSSML = /<speak[\\s\\S]*?>/iu.test(currentUtterance.text);\n\n          if (currentUtterance.voice && (currentUtterance.voice.voiceURI || currentUtterance.voice._name)) {\n            this.createSynthesizer(currentUtterance.voice.voiceURI || currentUtterance.voice._name, stream);\n          } else {\n            this.createSynthesizer(undefined, stream);\n          }\n\n          // Set volume / mute status if present in the utterance parameters\n          currentUtterance.volume && (this.speakerAudioDestination.volume = currentUtterance.volume);\n\n          // SpeakerAudioDestination events callbacks\n          this.speakerAudioDestination.onAudioStart = () => {\n            this.speaking = true;\n            currentUtterance.onstart && currentUtterance.onstart();\n          };\n\n          this.speakerAudioDestination.onAudioEnd = () => {\n            this.speaking = false;\n            currentUtterance.onend && currentUtterance.onend();\n            processQueue(); // Process the next queued utterance after the current one has finished\n          };\n\n          this.linkEventsCallbacks(currentUtterance);\n\n          return isSSML\n            ? new Promise(reject => {\n                this.synth &&\n                  this.synth.speakSsmlAsync(\n                    currentUtterance.text,\n                    result => {\n                      if (result) {\n                        this.synth && this.synth.close();\n                      } else {\n                        reject(new Error('No synthesis result.'));\n                      }\n                    },\n                    error => {\n                      reject(new Error(`Synthesis failed : ${error}`));\n                    }\n                  );\n              })\n            : new Promise(reject => {\n                this.synth &&\n                  this.synth.speakTextAsync(\n                    currentUtterance.text,\n                    result => {\n                      if (result) {\n                        this.synth && this.synth.close();\n                      } else {\n                        reject(new Error('No synthesis result.'));\n                      }\n                    },\n                    error => {\n                      reject(new Error(`Synthesis failed : ${error}`));\n                    }\n                  );\n              });\n        }\n      }\n    };\n\n    processQueue(); // Start processing the queue\n    this.canceled = false; // Reset canceled state after processing the queue\n  }\n\n  /**\n   * Launch synthesis without sound being played and call callback function with an ArrayBuffer after synthesis finished, containing the sound data\n   * @param {SpeechSynthesisUtterance} utterance\n   * @param {Function} callback\n   */\n  synthesizeAndGetArrayData(utterance, callback) {\n    // Test utterance\n    if (!(utterance instanceof SpeechSynthesisUtterance)) {\n      throw new Error('invalid utterance');\n    }\n\n    const isSSML = /<speak[\\s\\S]*?>/iu.test(utterance.text);\n    if (this.speechConfig) {\n      if (utterance.voice && (utterance.voice.voiceURI || utterance.voice._name)) {\n        const tempSpeechConfig = this.speechConfig;\n        tempSpeechConfig.speechSynthesisVoiceName = utterance.voice.voiceURI || utterance.voice._name;\n        // @ts-ignore\n        this.synth = new SDK.SpeechSynthesizer(tempSpeechConfig, null);\n      } else {\n        // @ts-ignore\n        this.synth = new SDK.SpeechSynthesizer(this.speechConfig, null);\n      }\n    }\n\n    this.linkEventsCallbacks(utterance);\n\n    try {\n      isSSML\n        ? this.synth &&\n          this.synth.speakSsmlAsync(\n            utterance.text,\n            result => {\n              if (result && result.audioData) {\n                callback(result.audioData);\n                this.synth && this.synth.close();\n              } else {\n                callback(null);\n              }\n            },\n            error => {\n              console.error(error);\n              callback(null);\n            }\n          )\n        : this.synth &&\n          this.synth.speakTextAsync(\n            utterance.text,\n            result => {\n              if (result && result.audioData) {\n                callback(result.audioData);\n                this.synth && this.synth.close();\n              } else {\n                callback(null);\n              }\n            },\n            error => {\n              console.error(error);\n              callback(null);\n            }\n          );\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Asynchronous function that updates available voices\n  async updateVoices() {\n    const voicesResult = this.synth ? await this.synth.getVoicesAsync() : null;\n    const voices = voicesResult?.voices;\n\n    if (Array.isArray(voices)) {\n      const formattedVoices: Array<SpeechSynthesisVoice> = voices.map(\n        voice =>\n          new SpeechSynthesisVoice({\n            // eslint-disable-next-line no-magic-numbers\n            gender: voice.gender === 1 ? 'Female' : voice.gender === 2 ? 'Male' : 'Undefined',\n            lang: voice.locale,\n            voiceURI: voice.name\n          })\n      );\n\n      this.getVoices = () => formattedVoices;\n    } else {\n      console.warn(\"Failed to retrieve voices. 'voices' is not an array.\");\n    }\n\n    // Call 'onvoiceschanged' callback to notify the voices update\n    this.onvoiceschanged();\n  }\n}\n\nconst createSpeechSynthesisPonyfill = (options: PatchOptions): SpeechSynthesisPonyfillType => {\n  return {\n    speechSynthesis: new SpeechSynthesis(options),\n    SpeechSynthesisUtterance\n  };\n};\n\nexport default createSpeechSynthesisPonyfill;\nexport { createSpeechSynthesisPonyfill, SpeechSynthesis };\n","/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\nimport type { SpeechSynthesisEventProps } from '../../models/speechtypes';\n\nclass SpeechSynthesisUtterance extends EventTarget {\n  _lang: string | undefined = undefined;\n  _pitch: number | undefined = 1;\n  _rate: number | undefined = 1;\n  _voice: SpeechSynthesisVoice | undefined = undefined;\n  _volume: number | undefined = 1;\n  text: string;\n\n  constructor(text: string) {\n    super();\n\n    this.text = text;\n  }\n\n  get lang(): string | undefined {\n    return this._lang;\n  }\n\n  set lang(value: string | undefined) {\n    this._lang = value;\n  }\n\n  get pitch(): number | undefined {\n    return this._pitch;\n  }\n\n  set pitch(value: number) {\n    this._pitch = value;\n  }\n\n  get rate(): number | undefined {\n    return this._rate;\n  }\n\n  set rate(value: number) {\n    this._rate = value;\n  }\n\n  get voice(): SpeechSynthesisVoice | undefined {\n    return this._voice;\n  }\n\n  set voice(value: SpeechSynthesisVoice | undefined) {\n    this._voice = value;\n  }\n\n  get volume(): number | undefined {\n    return this._volume;\n  }\n\n  set volume(value: number) {\n    this._volume = value;\n  }\n\n  onstart(): void {}\n\n  onend(): void {}\n\n  onerror(error: any): void {\n    console.log(error);\n  }\n\n  onsynthesisstart(): void {}\n\n  onsynthesiscompleted(): void {}\n\n  onboundary(_data: SpeechSynthesisEventProps): void {}\n\n  onviseme(_data: SpeechSynthesisEventProps): void {}\n\n  onmark(_data: SpeechSynthesisEventProps): void {}\n}\n\nexport default SpeechSynthesisUtterance;\n","import type { VoiceProps } from \"../../models/voiceTypes\";\n\nexport default class {\n  _default = false\n  _gender: string;\n  _lang: string;\n  _localService = false;\n  _name: string;\n  _voiceURI: string;\n\n  constructor({ gender, lang, voiceURI }: VoiceProps) {\n    this._gender = gender;\n    this._lang = lang;\n    this._name = voiceURI;\n    this._voiceURI = voiceURI;\n  }\n\n  get default() {\n    return this._default;\n  }\n\n  get gender() {\n    return this._gender;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  get localService() {\n    return this._localService;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get voiceURI() {\n    return this._voiceURI;\n  }\n}\n","import type { Credentials } from \"../models/credentialTypes\";\n\nconst TOKEN_URL_TEMPLATE = 'https://{region}.api.cognitive.microsoft.com/sts/v1.0/issueToken';\n\nexport default async function ({ region, subscriptionKey }: Credentials): Promise<string> {\n  if (!region || !subscriptionKey) {\n    throw new Error('Region AND subscription must be provided'); \n  } else {\n    const res = await fetch(\n      TOKEN_URL_TEMPLATE.replace(/\\{region\\}/u, region),\n      {\n        headers: {\n          'Ocp-Apim-Subscription-Key': subscriptionKey\n        },\n        method: 'POST'\n      }\n    );\n  \n    if (!res.ok) {\n      throw new Error(`Failed to fetch authorization token, server returned ${res.status}`);\n    }\n  \n    return res.text();\n  }\n}\n"],"names":[],"version":3,"file":"index.js.map"}